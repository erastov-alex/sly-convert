import os
import supervisely as sly
import yaml
from yaml.loader import SafeLoader
import shutil
import xml.etree.ElementTree as ET
from pycocotools.coco import COCO
import numpy as np
import json
import shutil
from PIL import Image

from tqdm import tqdm
from dotenv import load_dotenv
from supervisely.io.json import load_json_file

class Image():
    @classmethod
    def pixeliz(cls,
                img_path: str):
        img = sly.imaging.image.read(img_path)
        mask = img[:, :, 0].astype(int)
        return mask
    
    @classmethod
    def getsize(cls,
                mask):
        return len(mask) , len(mask[0]) 

    def __init__(self,
                 img_path = None):
        if not img_path:
            raise NotImplemented('Image not founded')
        self.img_path = img_path
        self.height, self.width = self.getsize(self.pixeliz(self.img_path))
        self.size = self.height, self.width
        self.name = os.path.basename(self.img_path)
                
class Annotation():
    def __init__(self,
                 data: list or tuple, #list of label+(geometry), example [[lable_name,(geometry)],[label,(geomerty)]...]
                 image: Image)->list:
        self.labels = []
        self.image = image
        for obj in data:
            label = Label(obj)
            self.labels.append(label)
        pass

    # def __iter__(self):
    #     self.index = 0
    #     return self.labels
    
    # def __next__(self):
    #     if self.index <= len(self.labels):
    #         self.index+=1
    #         return self.labels[self.index]
    
class Label():
    def __init__(self,
                 obj : tuple or list): #[lable_name,(geometry)]
        self.name = obj[0]
        self.geometry = obj[1]
        if len(self.geometry[0]) == 1:
            self.geometry = sly.Rectangle(left= self.geometry[0],
                                          top= self.geometry[1],
                                          right= self.geometry[2],
                                          bottom= self.geometry[3])
        elif len(self.geometry[0]) == 2:
            self.geometry = sly.Polygon(self.geometry)
        else:
            self.geometry = sly.Bitmap(self.geometry)

class Dataset():
    data_path = 'input'

    @classmethod
    def findby_ext(cls, extension):
        for rootdir, dirs, files in os.walk(cls.data_path):
            for file in files:       
                if file.endswith(extension):
                    return rootdir, os.path.join(rootdir, file), file
                
    @classmethod
    def findby_name(cls, 
                    name,
                    datapath = 'input',
                    avoid_path = None):
        for rootdir, dirs, files in os.walk(datapath):
            if rootdir == avoid_path:
                continue
            else:
                for file in files:       
                    if name in file:
                        return rootdir, os.path.join(rootdir, file), file
        return None

    def __init__(self, name = "Dataset_1"):
        self.root= []
        self.name = name
        self.img_ext = self.img_ext_func()
        if not self.img_ext:
            raise NotImplementedError()
        self.img_path = self.findby_ext(self.img_ext)[0]
        self.ann_path = 'input'
        print(f'{self.name} found at {self.data_path} "')

    def img_ext_func(self):
        jpegfound = False # means that image ISNOT png file 
        self.img_ext = None
        for rootdir, dirs, files in os.walk(self.data_path):
            for file in files:
                if file.endswith('jpg'):
                    self.img_ext = 'jpg'
                    jpegfound = True 
                elif file.endswith('jpeg'):
                    self.img_ext = 'jpeg'
                    jpegfound = True
                elif file.endswith('png'):
                    if not jpegfound:
                        self.img_ext = 'png'
                    else:
                        print('PNG MASKs FOUNDED')
                        return 'mask'
        if not self.img_ext:
            raise NotImplemented
        return self.img_ext

    def scan(self):
        flag = True
        root = []
        for img in os.listdir(self.img_path):
            img = Image(os.path.join(self.img_path, img))
            if self.__class__ != Coco:   
                ann_file = self.findby_name(os.path.splitext(img.name)[0],
                                            datapath=self.ann_path,
                                            avoid_path=self.img_path)
                if flag:
                    if ann_file == None:
                        ann_file = self.findby_name('instances.json')
                        self = Coco(self)
                        flag = False
                    elif ann_file[2].endswith(".yaml"):
                        self = Yolo(self)
                        flag = False
                    elif ann_file[2].endswith(".xml" or ".mat"):
                        self = Pascal(self)
                        flag = False
                    elif ann_file[2].endswith(".json"):
                        self = Cityscapes(self)
                        flag = False
                    elif self.img_ext == 'mask':
                    #self = Mask(self)
                    #Mask.convert(self)
                        raise ImportError
            else:
                ann_file = self.findby_name('instances.json')
            annotation = Annotation(self.parse(ann_file[1],img), img)
            root.append((img, annotation))
        return root

    def dump_sly(self):
        try:
            os.makedirs(os.path.join('output_sly', 'ann'))
            os.makedirs(os.path.join('output_sly', 'img'))
        except Exception as e:
            print('Folders already created')
        meta = sly.ProjectMeta()
        uniq_cats = []
        for obj in self.root:
            for label in obj[1].labels:
                uniq_cats.append((label.name, type(label.geometry)))
        uniq_cats = set(uniq_cats)
        for cat in uniq_cats:
            obj_class = sly.ObjClass(cat[0], cat[1])
            meta = meta.add_obj_class(obj_class)
        meta_json = meta.to_json()
        sly.json.dump_json_file(meta_json, os.path.join('output_sly', "meta.json"))
        i=0
        for obj in self.root:
            shutil.copy2(os.path.join(obj[0].img_path),'output_sly/img')
            sly_labels = []
            for label in obj[1].labels:
                geometry = label.geometry
                obj_class = meta.get_obj_class(obj_class_name= label.name)
                sly_label = sly.Label(geometry, obj_class)
                sly_labels.append(sly_label)
            sly_ann = sly.Annotation(img_size= obj[0].size, labels=sly_labels,image_id= i)
            ann_json = sly_ann.to_json()
            ann_path_json = os.path.join('output_sly\\ann', obj[0].name +'.json')
            sly.json.dump_json_file(ann_json, ann_path_json)
            i+=1
        print('DONE')

    def upload(self):
        path_advanced = os.path.expanduser("~\\env\\advanced.env")
        path_local = os.path.expanduser("~\\env\\local.env")
        path_supervisely = os.path.expanduser("~\\env\\supervisely.env")
        if sly.is_production():
            load_dotenv(path_advanced)
        else:
            load_dotenv(path_local)
        load_dotenv(os.path.expanduser(path_supervisely ))
        # Get ENV variables
        WORKSPACE_ID = sly.env.workspace_id()
        # Create api object to communicate with Supervisely Server
        api = sly.Api.from_env()
        # Initialize application
        app = sly.Application()
        input_name = input('Set project name \n')
        # Create project and dataset on Supervisely server
        project = api.project.create(WORKSPACE_ID, input_name , change_name_if_conflict=True)
        dataset = api.dataset.create(project.id, "ds0", change_name_if_conflict=True)
        project_id = project.id
        path_to_meta = "output_sly\meta.json"
        project_meta_json = load_json_file(path_to_meta)
        api.project.update_meta(project_id, project_meta_json)
        images_names = []
        images_paths = []
        for file in os.listdir('output_sly\img'):
            file_path = os.path.join('output_sly\img', file)
            images_names.append(file)
            images_paths.append(file_path)
        ann_names = []
        ann_paths = []
        for file in os.listdir('output_sly\\ann'):
            file_path = os.path.join('output_sly\\ann', file)
            ann_names.append(file)
            ann_paths.append(file_path)
        #Process folder with images and upload them to Supervisely server
        with tqdm(total=len(images_paths)) as pbar:
            for img_name, img_path, ann_path in zip(images_names, images_paths, ann_paths):
                try:
                    # Upload image and annotation into dataset on Supervisely server
                    info = api.image.upload_path(dataset_id=dataset.id, name=img_name, path=img_path)
                    sly.logger.trace(f"Image has been uploaded: id={info.id}, name={info.name}")
                    inf_ann = api.annotation.upload_path(img_id= info.id, ann_path=ann_path)
                    sly.logger.trace(f"Annotation has been uploaded")
                except Exception as e:
                    sly.logger.warn("Skip image", extra={"name": img_name, "reason": repr(e)})
                finally:
                    # Update progress bar
                    pbar.update(1)
        sly.logger.info(f"Result project: id={project.id}, name={project.name}")
        pass

class Coco(Dataset):#WORKS WITH POLYGONS
    def __init__(self, name="Coco"):
        super().__init__(name=name)
        self.ann_path = Dataset.findby_ext('json')[0]
    
    def segmentation_data_fixer(self, segmentation):
        segmentation_result=[]
        list_hash = []
        for i in range(len(segmentation[0])):
            list_hash.append(segmentation[0][i])
            if len(list_hash) == 2:
                list_hash.reverse()
                segmentation_result.append(list_hash)
                list_hash=[]
        return segmentation_result

    def parse(self,
              path_to_instances: str,
              img: Image):
        annotation = []
        coco = COCO(path_to_instances)
        categories = coco.cats
        images = coco.imgs
        annotations = coco.imgToAnns
        for key, value in images.items():
            if value['file_name'] == img.name:
                for label in annotations[key]:
                    geometry = self.segmentation_data_fixer(label['segmentation'])
                    cat_id = label["category_id"]
                    label_name = categories[cat_id]['name']
                    annotation.append([label_name, geometry])
        return annotation

class Cityscapes(Dataset):
    def __init__(self, name="Dataset_1", data_path="~/input"):
        name = 'Cityscapes_Dataset'
        super().__init__(name, data_path)

class Pascal(Dataset): #WORKS WITH RECTANGLES
    def __init__(self, name='Pacsal_Dataset'):
        super().__init__(name=name)
        self.ann_path = Dataset.findby_ext('xml')[0]

    def parse(self,
              path_to_xml: str,
              img: Image):
        # parse xml file
        assert os.path.isfile(path_to_xml)
        tree = ET.parse(path_to_xml) 
        root = tree.getroot()
        annotation = []
        for member in root.findall('object'):
            # bbox coordinates
            label_name = member[0].text
            xmin = int(member[5][0].text)
            ymin = int(member[5][1].text)
            xmax = int(member[5][2].text)
            ymax = int(member[5][3].text)
            geometry = xmin, ymin, xmax, ymax
            # store data in list
            annotation.append([label_name, geometry])
        return annotation

class Yolo(Dataset): 
    def __init__(self, data_path):
        name = 'YOLO_Dataset'
        self.ann_path = Dataset.findby_ext('json')
        super().__init__(self, name=name)

a = Dataset()
a.root = a.scan()
a.dump_sly()
a.upload()