import os
import supervisely as sly
import yaml
from yaml.loader import SafeLoader
import shutil
import xml.etree.ElementTree as ET
from pycocotools.coco import COCO
import numpy as np
import json
import shutil
from PIL import Image

from tqdm import tqdm
from dotenv import load_dotenv
from supervisely.io.json import load_json_file

class Label():
    def __init__(self, data, img_size):
        self.name = data[0]
        self.img_size = img_size
        if len(data[1])==4:
            bbox = data[1]
            self.geometry = sly.Rectangle(left= bbox[0],top= bbox[1],right= bbox[2],bottom= bbox[3])
        elif len(data[1])>4:
            segmentation = data[1]
            self.geometry = sly.Polygon(segmentation)
        else:
            self.geometry = sly.Bitmap(data[1])
    pass

class Annotation():
    def __init__(self, data, img_size) ->list:
        self.labels = []
        self.img_size = img_size
        for obj in data:
            label = Label(obj, img_size)
            self.labels.append(label)
        pass

class Dataset():
    def __init__(self, name = "Dataset_1", data_path = "~/input", 
                img_path = None, ann_path = None, img_ext = 'None', labels = []):
        self.name = name
        self.data_path = data_path
        self.img_ext = img_ext
        self.img_path = img_path
        self.ann_path = ann_path
        self.labels = labels
        print(f'{self.name} found at {self.data_path} "')
        pass

    def format(self):
        for rootdir, dirs, files in os.walk('input'):
            for file in files:       
                if file.endswith(".yaml"):
                    self = Yolo(self)
                    return self
                elif file.endswith(".xml" or ".png"):
                    self = Pascal(self)
                    return self
                elif file == 'instances.json':
                    self = Coco(self)
                    return self
                elif file.endswith(".json"):
                    self = Cityscapes(self)
                    return self
                elif Dataset.image_extension(self) == 'mask':
                    #self = Mask(self)
                    #Mask.convert(self)
                    break

    def findby_ext(self, extension):
        for rootdir, dirs, files in os.walk('input'):
            for file in files:       
                if((file.split('.')[-1])==extension):
                    return rootdir, os.path.join(rootdir, file), file
        return None
    
    def findby_name(self, name):
        for rootdir, dirs, files in os.walk('input'):
            for file in files:       
                if name in file:
                    return rootdir, os.path.join(rootdir, file), file
        return None

    def image_extension(self):

        jpegfound = False
        self.img_ext = None
        for rootdir, dirs, files in os.walk('input'):
            for file in files:
                if file.endswith('jpg'):
                    self.img_ext = 'jpg'
                    jpegfound = True # means that image ISNOT png file 
                elif file.endswith('jpeg'):
                    self.img_ext = 'jpeg'
                    jpegfound = True
                elif file.endswith('png'):
                    if not jpegfound:
                        self.img_ext = 'png'
                    else:
                        print('PNG MASKs FOUNDED')
                        return 'mask'
        return self.img_ext

    def create_annotation(self, file, annotation, meta, image_index):
        '''ANNOTATION - LIST OF TUPLES, EXAMPLE: [(kiwi,[193,92,255,192]),....]'''
        sly_labels = []
        for label in annotation.labels:
            geometry = label.geometry
            obj_class = meta.get_obj_class(obj_class_name= label.name)
            sly_label = sly.Label(geometry= geometry, obj_class= obj_class)
            sly_labels.append(sly_label)
        sly_ann = sly.Annotation(img_size= annotation.img_size, labels=sly_labels,image_id= image_index)
        ann_json = sly_ann.to_json()
        ann_path_json = os.path.join(self.ann_path, file +'.json')
        sly.json.dump_json_file(ann_json, ann_path_json)
        pass

class Yolo(Dataset): #WORKS
    def __init__(self, data_path):
        name = 'YOLO_Dataset'
        self.img_path = Dataset.findby_ext(Dataset.image_extension(self))
        self.ann_path = Dataset.findby_ext('json')
        super().__init__(self, name, data_path, img_path = None, ann_path = None)
    
    def getlabels(self):
        yaml_meta = Dataset.findby_ext(self, 'yaml')[1]
        with open(yaml_meta) as f:
            data = yaml.load(f, Loader=SafeLoader)
            names = data['names']
        return names

class Pascal(Dataset): #WORKS
    def __init__(self, name="Dataset_1", data_path="~/input"):
        name = 'Pacsal_Dataset'
        self.img_path = Dataset.findby_ext(self, Dataset.image_extension(self))[0]
        self.ann_path = Dataset.findby_ext(self, 'xml')[0]
        super().__init__(name, data_path, img_path=self.img_path, ann_path=self.ann_path)
        
    def getlabels(self):
        for file in os.listdir(self.ann_path):
            annotation = Pascal.parse(self, os.path.join(self.ann_path, file))
            names = []
            for item in annotation.labels:
                names.append(item.name)
        return np.unique(annotation)
    
    def parse(self, path_to_xml):
        # parse xml file
        assert os.path.isfile(path_to_xml)
        tree = ET.parse(path_to_xml) 
        root = tree.getroot()
        annotation = []
        height = int(root.find("size")[0].text)
        width = int(root.find("size")[1].text)
        img_size = width, height
        for member in root.findall('object'):
            # bbox coordinates
            xmin = int(member[5][0].text)
            ymin = int(member[5][1].text)
            xmax = int(member[5][2].text)
            ymax = int(member[5][3].text) 
            # store data in list
            annotation.append([member[0].text, (xmin, ymin, xmax, ymax)])
        annotation = Annotation(annotation, img_size)
        return annotation
   
class Coco(Dataset):
    def __init__(self, name="Dataset_1", data_path="~/input"):
        super().__init__(name, data_path)

class Cityscapes(Dataset):
    def __init__(self, name="Dataset_1", data_path="~/input"):
        name = 'Cityscapes_Dataset'
        super().__init__(name, data_path)
    
class Convert():
    def __init__(self, input = 'input', dataset = None):
        self.input = input
        self.dataset = dataset
    
    def img_moover(self, extension, file_source = 'input'):
        for rootdir, dirs, files in os.walk(file_source):
            for file in files: 
                    if file.endswith(extension):
                        shutil.copy2(os.path.join(rootdir, file),'output_sly/img')
        pass
        
    def folder_creator():
        try:
            os.makedirs('output_sly/ann')
            os.makedirs('output_sly/img')
        except Exception as e:
            print('Folders already created')
        pass

    def run(self):
        Convert.folder_creator()
        dataset = Dataset.format(self.dataset)
        Convert.img_moover(dataset, extension=Dataset.image_extension(dataset))
        meta = sly.ProjectMeta()
        for obj in dataset.getlabels(): 
            for label in obj.labels:
                obj_class = sly.ObjClass(label.name, label.geometry)
                meta = meta.add_obj_class(obj_class)
        meta_json = meta.to_json()
        sly.json.dump_json_file(meta_json, os.path.join('output_sly', "meta.json"))
        i=0
        for file in os.listdir('output_sly/img'):
            annotation_path = Dataset.findby_name(dataset, file[:6])[1]
            annotation = dataset.parse(annotation_path)
            Dataset.create_annotation(dataset, file, annotation, meta, image_index=i)
            i+=1
        print('DONE')


dataset = Dataset()
converter = Convert(dataset=dataset)
converter.run()





        





